<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>QuantumSafe RLWE Cryptosystem - Полная версия</title>
    <style>
        :root {
            --primary-dark: #0d1b2a;
            --primary: #1b263b;
            --secondary: #415a77;
            --accent: #778da9;
            --light: #e0e1dd;
            --success: #4cc9f0;
            --warning: #f72585;
            --danger: #e63946;
        }
        
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            font-family: 'Consolas', 'Monaco', monospace;
        }
        
        body {
            background: linear-gradient(135deg, var(--primary-dark), var(--primary));
            color: var(--light);
            min-height: 100vh;
            padding: 20px;
            line-height: 1.6;
        }
        
        .container {
            max-width: 1400px;
            margin: 0 auto;
            background: rgba(27, 38, 59, 0.95);
            border-radius: 15px;
            padding: 30px;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.5);
            border: 1px solid var(--accent);
        }
        
        header {
            text-align: center;
            margin-bottom: 40px;
            padding: 20px;
            background: rgba(13, 27, 42, 0.7);
            border-radius: 10px;
            border: 1px solid var(--secondary);
        }
        
        h1 {
            font-size: 2.8rem;
            margin-bottom: 10px;
            color: var(--success);
            text-shadow: 0 2px 10px rgba(76, 201, 240, 0.3);
        }
        
        .subtitle {
            font-size: 1.2rem;
            color: var(--accent);
            margin-bottom: 20px;
        }
        
        .warning {
            background: linear-gradient(135deg, #f72585, #e63946);
            padding: 15px;
            border-radius: 8px;
            margin: 20px 0;
            text-align: center;
            font-weight: bold;
        }
        
        .tab-container {
            display: flex;
            margin-bottom: 20px;
            background: rgba(13, 27, 42, 0.7);
            border-radius: 10px;
            overflow: hidden;
            flex-wrap: wrap;
        }
        
        .tab {
            flex: 1;
            padding: 15px;
            text-align: center;
            cursor: pointer;
            transition: all 0.3s ease;
            border-bottom: 3px solid transparent;
            min-width: 120px;
        }
        
        .tab.active {
            background: rgba(76, 201, 240, 0.2);
            border-bottom: 3px solid var(--success);
        }
        
        .tab-content {
            display: none;
        }
        
        .tab-content.active {
            display: block;
        }
        
        .panel {
            background: rgba(21, 31, 46, 0.9);
            border-radius: 12px;
            padding: 25px;
            border: 1px solid var(--secondary);
            box-shadow: 0 5px 20px rgba(0, 0, 0, 0.3);
            margin-bottom: 20px;
        }
        
        .panel h2 {
            color: var(--success);
            margin-bottom: 20px;
            padding-bottom: 10px;
            border-bottom: 2px solid var(--secondary);
            font-size: 1.5rem;
        }
        
        .input-group {
            margin-bottom: 20px;
        }
        
        label {
            display: block;
            margin-bottom: 8px;
            font-weight: 600;
            color: var(--accent);
            font-size: 1rem;
        }
        
        input, textarea, select {
            width: 100%;
            padding: 14px;
            border: none;
            border-radius: 8px;
            background: rgba(13, 27, 42, 0.8);
            color: var(--light);
            font-size: 1rem;
            border: 1px solid var(--secondary);
            transition: all 0.3s ease;
        }
        
        input:focus, textarea:focus, select:focus {
            outline: none;
            border-color: var(--success);
            box-shadow: 0 0 15px rgba(76, 201, 240, 0.2);
        }
        
        textarea {
            min-height: 150px;
            resize: vertical;
            font-family: monospace;
            line-height: 1.5;
        }
        
        button {
            background: linear-gradient(135deg, var(--secondary), var(--accent));
            color: white;
            border: none;
            padding: 15px 25px;
            border-radius: 8px;
            cursor: pointer;
            font-size: 1rem;
            font-weight: 600;
            transition: all 0.3s ease;
            width: 100%;
            margin-top: 15px;
        }
        
        button:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.3);
        }
        
        .btn-encrypt {
            background: linear-gradient(135deg, #2a9d8f, #264653);
        }
        
        .btn-decrypt {
            background: linear-gradient(135deg, #e76f51, #f4a261);
        }
        
        .btn-generate {
            background: linear-gradient(135deg, #7209b7, #3a0ca3);
        }
        
        .btn-clear {
            background: linear-gradient(135deg, var(--warning), var(--danger));
        }
        
        .btn-apply {
            background: linear-gradient(135deg, #4361ee, #3a0ca3);
        }
        
        .result {
            margin-top: 20px;
            padding: 20px;
            border-radius: 8px;
            background: rgba(13, 27, 42, 0.8);
            min-height: 120px;
            border: 1px solid var(--secondary);
            font-family: monospace;
            white-space: pre-wrap;
            word-break: break-all;
            overflow-y: auto;
            max-height: 300px;
        }
        
        .result-label {
            font-size: 1rem;
            color: var(--success);
            margin-bottom: 10px;
            font-weight: 600;
        }
        
        .status-bar {
            display: flex;
            align-items: center;
            gap: 15px;
            margin-top: 20px;
            padding: 15px;
            background: rgba(13, 27, 42, 0.8);
            border-radius: 8px;
            border: 1px solid var(--secondary);
        }
        
        .status-indicator {
            width: 15px;
            height: 15px;
            border-radius: 50%;
            background: var(--success);
        }
        
        .status-working {
            animation: pulse 1.5s infinite;
            background: var(--success);
        }
        
        .status-error {
            background: var(--danger);
        }
        
        @keyframes pulse {
            0% { opacity: 0.6; }
            50% { opacity: 1; }
            100% { opacity: 0.6; }
        }
        
        .key-display {
            margin-top: 15px;
            padding: 15px;
            background: rgba(13, 27, 42, 0.7);
            border-radius: 8px;
            border: 1px solid var(--secondary);
            word-break: break-all;
            font-family: monospace;
            max-height: 200px;
            overflow-y: auto;
        }
        
        .key-actions {
            display: flex;
            gap: 10px;
            margin-top: 10px;
            flex-wrap: wrap;
        }
        
        .key-actions button {
            flex: 1;
            margin-top: 0;
            padding: 10px;
            min-width: 120px;
        }
        
        .progress-container {
            margin: 20px 0;
            background: rgba(13, 27, 42, 0.8);
            border-radius: 8px;
            height: 20px;
            overflow: hidden;
        }
        
        .progress-bar {
            height: 100%;
            background: linear-gradient(90deg, var(--secondary), var(--success));
            width: 0%;
            transition: width 0.5s ease;
        }
        
        .settings-panel {
            background: rgba(13, 27, 42, 0.7);
            border-radius: 8px;
            padding: 15px;
            margin-top: 20px;
            border: 1px solid var(--secondary);
        }
        
        .settings-row {
            display: flex;
            gap: 15px;
            margin-bottom: 15px;
            align-items: center;
            flex-wrap: wrap;
        }
        
        .settings-row label {
            margin-bottom: 0;
            min-width: 150px;
        }
        
        .settings-row select, .settings-row input {
            flex: 1;
            margin-bottom: 0;
            min-width: 200px;
        }
        
        .format-options {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(300px, 1fr));
            gap: 15px;
            margin-top: 15px;
        }
        
        .format-option {
            padding: 15px;
            background: rgba(27, 38, 59, 0.7);
            border-radius: 8px;
            border: 1px solid var(--secondary);
        }
        
        footer {
            text-align: center;
            margin-top: 40px;
            padding: 20px;
            color: var(--accent);
            font-size: 0.9rem;
            border-top: 1px solid var(--secondary);
        }
        
        .modal {
            display: none;
            position: fixed;
            z-index: 1000;
            left: 0;
            top: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.7);
        }
        
        .modal-content {
            background: var(--primary);
            margin: 10% auto;
            padding: 20px;
            border-radius: 10px;
            width: 80%;
            max-width: 600px;
            border: 2px solid var(--accent);
        }
        
        .close {
            color: var(--accent);
            float: right;
            font-size: 28px;
            font-weight: bold;
            cursor: pointer;
        }
        
        .close:hover {
            color: var(--light);
        }
        
        @media (max-width: 768px) {
            .tab {
                min-width: 100px;
                padding: 10px;
            }
            
            .settings-row {
                flex-direction: column;
                align-items: flex-start;
            }
            
            .settings-row select, .settings-row input {
                width: 100%;
            }
            
            .key-actions {
                flex-direction: column;
            }
            
            .modal-content {
                width: 95%;
                margin: 5% auto;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <header>
            <h1>QuantumSafe RLWE Cryptosystem</h1>
            <p class="subtitle">Полная рабочая реализация криптосистемы на кольцевых решетках</p>
            <div class="warning">
                ⚠️ ВНИМАНИЕ: Это демонстрационная реализация. Не используйте для защиты реальных данных!
            </div>
        </header>
        
        <div class="tab-container">
            <div class="tab active" onclick="switchTab('params')">Параметры</div>
            <div class="tab" onclick="switchTab('keys')">Ключи</div>
            <div class="tab" onclick="switchTab('encrypt')">Шифрование</div>
            <div class="tab" onclick="switchTab('decrypt')">Дешифрование</div>
            <div class="tab" onclick="switchTab('formats')">Форматы</div>
        </div>
        
        <div class="tab-content active" id="params-tab">
            <div class="panel">
                <h2>Параметры безопасности</h2>
                
                <div class="settings-row">
                    <label for="securityLevel">Уровень безопасности:</label>
                    <select id="securityLevel">
                        <option value="128">128 бит (n=512)</option>
                        <option value="192" selected>192 бит (n=1024)</option>
                        <option value="256">256 бит (n=2048)</option>
                    </select>
                </div>
                
                <div class="settings-row">
                    <label for="modulusType">Тип модуля:</label>
                    <select id="modulusType">
                        <option value="12289">q=12289 (NTT-дружественный)</option>
                        <option value="7681">q=7681 (Оптимизированный)</option>
                    </select>
                </div>
                
                <div class="settings-row">
                    <label for="errorDistribution">Распределение ошибок:</label>
                    <select id="errorDistribution">
                        <option value="gaussian">Дискретное гауссово (σ=3.2)</option>
                        <option value="uniform">Равномерное (более быстрое)</option>
                    </select>
                </div>
                
                <div class="settings-row">
                    <label for="encodingScheme">Схема кодирования:</label>
                    <select id="encodingScheme">
                        <option value="coefficient">Кодирование в коэффициенты</option>
                        <option value="ntt">NTT-представление</option>
                    </select>
                </div>
                
                <button class="btn-apply" onclick="saveParameters()">Применить параметры</button>
            </div>
        </div>
        
        <div class="tab-content" id="keys-tab">
            <div class="panel">
                <h2>Управление ключами</h2>
                
                <div class="input-group">
                    <label for="keyComment">Комментарий к ключам:</label>
                    <input type="text" id="keyComment" placeholder="Мои RLWE ключи">
                </div>
                
                <button class="btn-generate" onclick="generateKeyPair()">🔑 Сгенерировать ключевую пару</button>
                
                <div class="progress-container">
                    <div class="progress-bar" id="keyGenProgress"></div>
                </div>
                
                <div class="result">
                    <div class="result-label">Публичный ключ:</div>
                    <div class="key-display" id="publicKeyDisplay">Ключ не сгенерирован</div>
                    <div class="key-actions">
                        <button onclick="copyPublicKey()">📋 Копировать</button>
                        <button onclick="downloadPublicKey()">📥 Сохранить</button>
                        <button onclick="showPublicKeyInfo()">📊 Информация</button>
                    </div>
                </div>
                
                <div class="result">
                    <div class="result-label">Секретный ключ:</div>
                    <div class="key-display" id="secretKeyDisplay">Ключ не сгенерирован</div>
                    <div class="key-actions">
                        <button onclick="copySecretKey()">📋 Копировать</button>
                        <button onclick="downloadSecretKey()">📥 Сохранить</button>
                        <button onclick="showSecretKeyInfo()">📊 Информация</button>
                    </div>
                </div>
            </div>
        </div>
        
        <div class="tab-content" id="encrypt-tab">
            <div class="panel">
                <h2>Шифрование сообщения</h2>
                
                <div class="input-group">
                    <label for="recipientPublicKey">Публичный ключ получателя:</label>
                    <textarea id="recipientPublicKey" placeholder="Вставьте публичный ключ..."></textarea>
                </div>
                
                <div class="input-group">
                    <label for="messageToEncrypt">Сообщение для шифрования:</label>
                    <textarea id="messageToEncrypt" placeholder="Введите текст для шифрования...">Конфиденциальное сообщение, защищенное RLWE криптографией</textarea>
                </div>
                
                <div class="settings-row">
                    <label for="encryptionMode">Режим шифрования:</label>
                    <select id="encryptionMode">
                        <option value="standard">Стандартный</option>
                        <option value="authenticated">Аутентифицированный</option>
                    </select>
                </div>
                
                <button class="btn-encrypt" onclick="encryptMessage()">🔒 Зашифровать сообщение</button>
                
                <div class="progress-container">
                    <div class="progress-bar" id="encryptProgress"></div>
                </div>
                
                <div class="result">
                    <div class="result-label">Зашифрованное сообщение:</div>
                    <div id="encryptedMessageResult"></div>
                    <div class="key-actions">
                        <button onclick="copyEncryptedMessage()">📋 Копировать</button>
                        <button onclick="downloadEncryptedMessage()">📥 Сохранить</button>
                        <button onclick="analyzeCiphertext()">📊 Анализ</button>
                    </div>
                </div>
            </div>
        </div>
        
        <div class="tab-content" id="decrypt-tab">
            <div class="panel">
                <h2>Дешифрование сообщения</h2>
                
                <div class="input-group">
                    <label for="encryptedMessage">Зашифрованное сообщение:</label>
                    <textarea id="encryptedMessage" placeholder="Вставьте зашифрованное сообщение..."></textarea>
                </div>
                
                <div class="input-group">
                    <label for="decryptionKey">Секретный ключ для дешифрования:</label>
                    <textarea id="decryptionKey" placeholder="Вставьте ваш секретный ключ..."></textarea>
                </div>
                
                <button class="btn-decrypt" onclick="decryptMessage()">🔓 Расшифровать сообщение</button>
                
                <div class="progress-container">
                    <div class="progress-bar" id="decryptProgress"></div>
                </div>
                
                <div class="result">
                    <div class="result-label">Расшифрованное сообщение:</div>
                    <div id="decryptedMessageResult"></div>
                    <div class="key-actions">
                        <button onclick="copyDecryptedMessage()">📋 Копировать</button>
                        <button onclick="downloadDecryptedMessage()">📥 Сохранить</button>
                        <button onclick="verifyDecryption()">✅ Проверить</button>
                    </div>
                </div>
            </div>
        </div>
        
        <div class="tab-content" id="formats-tab">
            <div class="panel">
                <h2>Настройки форматов</h2>
                
                <div class="format-options">
                    <div class="format-option">
                        <h3>Форматы ключей</h3>
                        <div class="settings-row">
                            <label for="keyFormat">Формат представления:</label>
                            <select id="keyFormat">
                                <option value="json">JSON (полный)</option>
                                <option value="json-compact">JSON (компактный)</option>
                                <option value="base64">Base64</option>
                                <option value="hex">Hex</option>
                            </select>
                        </div>
                    </div>
                    
                    <div class="format-option">
                        <h3>Форматы сообщений</h3>
                        <div class="settings-row">
                            <label for="messageFormat">Формат шифротекста:</label>
                            <select id="messageFormat">
                                <option value="json">JSON Structured</option>
                                <option value="json-compact">JSON Compact</option>
                                <option value="base64">Base64</option>
                            </select>
                        </div>
                    </div>
                    
                    <div class="format-option">
                        <h3>Дополнительные опции</h3>
                        <div class="settings-row">
                            <label for="lineBreaks">Переносы строк:</label>
                            <select id="lineBreaks">
                                <option value="64">Через 64 символа</option>
                                <option value="76">Через 76 символов (стандарт)</option>
                                <option value="none">Без переносов</option>
                            </select>
                        </div>
                        
                        <div class="settings-row">
                            <label for="includeMetadata">Включать метаданные:</label>
                            <input type="checkbox" id="includeMetadata" checked>
                        </div>
                    </div>
                </div>
                
                <button class="btn-apply" onclick="applyFormatSettings()">Применить настройки форматов</button>
            </div>
        </div>
        
        <div class="status-bar">
            <div class="status-indicator" id="statusIndicator"></div>
            <span id="statusText">Система инициализирована. Выберите параметры безопасности.</span>
        </div>
        
        <footer>
            <p>QuantumSafe RLWE Cryptosystem v2.1 | Post-Quantum Cryptographic System | 2024</p>
        </footer>
    </div>

    <!-- Модальное окно для информации -->
    <div id="infoModal" class="modal">
        <div class="modal-content">
            <span class="close" onclick="closeModal()">&times;</span>
            <div id="modalContent"></div>
        </div>
    </div>

    <script>
        // ============ СИСТЕМНАЯ КОНФИГУРАЦИЯ ============
        const RLWE_CONFIG = {
            parameters: {
                '128': { n: 512, q: 12289, sigma: 3.2 },
                '192': { n: 1024, q: 12289, sigma: 3.2 },
                '256': { n: 2048, q: 12289, sigma: 3.2 }
            },
            formats: {
                key: 'json',
                message: 'json',
                lineBreaks: '76',
                includeMetadata: true
            },
            security: {
                level: '192',
                modulusType: '12289',
                errorDistribution: 'gaussian',
                encodingScheme: 'coefficient'
            }
        };

        // Глобальные состояния
        let currentPublicKey = null;
        let currentSecretKey = null;
        let currentParams = null;
        let currentCiphertext = null;
        let currentDecryptedMessage = null;

        // ============ МАТЕМАТИЧЕСКОЕ ЯДРО ============

        class Polynomial {
            constructor(coefficients, mod) {
                this.coefficients = coefficients;
                this.mod = mod;
                this.length = coefficients.length;
            }
            
            add(other) {
                const result = new Array(this.length);
                for (let i = 0; i < this.length; i++) {
                    result[i] = (this.coefficients[i] + other.coefficients[i]) % this.mod;
                }
                return new Polynomial(result, this.mod);
            }
            
            subtract(other) {
                const result = new Array(this.length);
                for (let i = 0; i < this.length; i++) {
                    result[i] = (this.coefficients[i] - other.coefficients[i] + this.mod) % this.mod;
                }
                return new Polynomial(result, this.mod);
            }
            
            multiply(other) {
                const result = new Array(this.length).fill(0);
                for (let i = 0; i < this.length; i++) {
                    for (let j = 0; j < this.length; j++) {
                        const k = (i + j) % this.length;
                        result[k] = (result[k] + this.coefficients[i] * other.coefficients[j]) % this.mod;
                    }
                }
                return new Polynomial(result, this.mod);
            }
            
            multiplyScalar(scalar) {
                const result = new Array(this.length);
                for (let i = 0; i < this.length; i++) {
                    result[i] = (this.coefficients[i] * scalar) % this.mod;
                }
                return new Polynomial(result, this.mod);
            }
            
            toArray() {
                return this.coefficients;
            }
        }

        class NTT {
            constructor(n, q) {
                this.n = n;
                this.q = q;
                this.omega = this.findPrimitiveRoot();
                this.invOmega = this.modInverse(this.omega, q);
                this.invN = this.modInverse(n, q);
            }
            
            findPrimitiveRoot() {
                // Для стандартных модулей используем известные корни
                if (this.q === 12289) return 3;
                if (this.q === 7681) return 17;
                
                // Общий алгоритм поиска примитивного корня
                const factors = this.getPrimeFactors(this.q - 1);
                
                for (let g = 2; g < this.q; g++) {
                    let valid = true;
                    for (const factor of factors) {
                        if (this.modPow(g, (this.q - 1) / factor, this.q) === 1) {
                            valid = false;
                            break;
                        }
                    }
                    if (valid) return g;
                }
                throw new Error("Primitive root not found");
            }
            
            getPrimeFactors(n) {
                const factors = new Set();
                while (n % 2 === 0) {
                    factors.add(2);
                    n = n / 2;
                }
                
                for (let i = 3; i <= Math.sqrt(n); i += 2) {
                    while (n % i === 0) {
                        factors.add(i);
                        n = n / i;
                    }
                }
                
                if (n > 2) factors.add(n);
                return Array.from(factors);
            }
            
            forward(poly) {
                return this.transform(poly, this.omega);
            }
            
            inverse(poly) {
                const result = this.transform(poly, this.invOmega);
                for (let i = 0; i < this.n; i++) {
                    result[i] = (result[i] * this.invN) % this.q;
                }
                return result;
            }
            
            transform(poly, root) {
                const result = [...poly];
                let len = this.n;
                
                for (let i = 1; i < len; i <<= 1) {
                    const wn = this.modPow(root, len / (2 * i), this.q);
                    
                    for (let j = 0; j < len; j += 2 * i) {
                        let w = 1;
                        
                        for (let k = 0; k < i; k++) {
                            const u = result[j + k];
                            const v = (result[j + k + i] * w) % this.q;
                            
                            result[j + k] = (u + v) % this.q;
                            result[j + k + i] = (u - v + this.q) % this.q;
                            
                            w = (w * wn) % this.q;
                        }
                    }
                }
                
                return result;
            }
            
            modPow(base, exponent, mod) {
                if (mod === 1) return 0;
                let result = 1;
                base = base % mod;
                
                while (exponent > 0) {
                    if (exponent % 2 === 1) {
                        result = (result * base) % mod;
                    }
                    exponent = Math.floor(exponent / 2);
                    base = (base * base) % mod;
                }
                
                return result;
            }
            
            modInverse(a, m) {
                let [t, newT] = [0, 1];
                let [r, newR] = [m, a];
                
                while (newR !== 0) {
                    const quotient = Math.floor(r / newR);
                    [t, newT] = [newT, t - quotient * newT];
                    [r, newR] = [newR, r - quotient * newR];
                }
                
                if (r > 1) throw new Error("a is not invertible");
                if (t < 0) t += m;
                return t;
            }
        }

        class GaussianSampler {
            constructor(sigma, bounds = 6) {
                this.sigma = sigma;
                this.bounds = bounds;
                this.min = -Math.floor(bounds * sigma);
                this.max = Math.floor(bounds * sigma);
                this.precomputed = this.precomputeDistribution();
            }
            
            precomputeDistribution() {
                const values = [];
                const probabilities = [];
                let total = 0;
                
                for (let x = this.min; x <= this.max; x++) {
                    const prob = Math.exp(-x * x / (2 * this.sigma * this.sigma));
                    values.push(x);
                    probabilities.push(prob);
                    total += prob;
                }
                
                // Создаем CDF для выборки
                const cdf = [];
                let cumulative = 0;
                
                for (let i = 0; i < values.length; i++) {
                    cumulative += probabilities[i] / total;
                    cdf.push({ value: values[i], cumulative });
                }
                
                return cdf;
            }
            
            sample() {
                const u = crypto.getRandomValues(new Uint32Array(1))[0] / 4294967296;
                
                for (const item of this.precomputed) {
                    if (u <= item.cumulative) {
                        return item.value;
                    }
                }
                
                return this.precomputed[this.precomputed.length - 1].value;
            }
            
            sampleArray(n) {
                const result = new Array(n);
                for (let i = 0; i < n; i++) {
                    result[i] = this.sample();
                }
                return result;
            }
        }

        // ============ ОСНОВНЫЕ ФУНКЦИИ RLWE ============

        function initializeRLWE() {
            const securityLevel = RLWE_CONFIG.security.level;
            currentParams = RLWE_CONFIG.parameters[securityLevel];
            
            updateStatus(`Инициализированы параметры: n=${currentParams.n}, q=${currentParams.q}`, 'ready');
        }

        function generateKeyPair() {
            if (!currentParams) {
                updateStatus('Сначала инициализируйте параметры', 'error');
                return;
            }

            updateStatus('Генерация ключей...', 'working');
            simulateProgress('keyGenProgress', 2000);
            
            setTimeout(() => {
                try {
                    const { n, q, sigma } = currentParams;
                    const sampler = new GaussianSampler(sigma);

                    // Генерация секретного ключа
                    currentSecretKey = sampler.sampleArray(n);

                    // Генерация ошибки
                    const error = sampler.sampleArray(n);

                    // Генерация случайного полинома a
                    const a = new Array(n);
                    const randomValues = new Uint32Array(n);
                    window.crypto.getRandomValues(randomValues);
                    
                    for (let i = 0; i < n; i++) {
                        a[i] = randomValues[i] % q;
                    }

                    // Вычисление b = a*s + e
                    const b = new Array(n).fill(0);
                    for (let i = 0; i < n; i++) {
                        for (let j = 0; j < n; j++) {
                            const k = (i + j) % n;
                            b[k] = (b[k] + a[i] * currentSecretKey[j]) % q;
                        }
                        b[i] = (b[i] + error[i]) % q;
                    }

                    currentPublicKey = {
                        a: a,
                        b: b,
                        params: currentParams,
                        timestamp: new Date().toISOString(),
                        comment: document.getElementById('keyComment').value || 'RLWE Key'
                    };

                    // Отображение ключей
                    displayKeys();
                    updateStatus('Ключевая пара успешно сгенерирована', 'ready');

                } catch (error) {
                    updateStatus('Ошибка генерации ключей: ' + error.message, 'error');
                }
            }, 100);
        }

        function encryptMessage() {
            if (!currentPublicKey) {
                updateStatus('Сначала сгенерируйте ключи', 'error');
                return;
            }

            const message = document.getElementById('messageToEncrypt').value;
            if (!message) {
                updateStatus('Введите сообщение для шифрования', 'error');
                return;
            }

            updateStatus('Шифрование сообщения...', 'working');
            simulateProgress('encryptProgress', 1500);

            setTimeout(() => {
                try {
                    const { n, q, sigma } = currentPublicKey.params;
                    const sampler = new GaussianSampler(sigma);

                    // Кодирование сообщения
                    const messagePoly = encodeMessage(message, n, q);

                    // Генерация случайных полиномов
                    const r = sampler.sampleArray(n);
                    const e1 = sampler.sampleArray(n);
                    const e2 = sampler.sampleArray(n);

                    // Шифрование: u = a*r + e1, v = b*r + e2 + message
                    const u = new Array(n).fill(0);
                    const v = new Array(n).fill(0);

                    for (let i = 0; i < n; i++) {
                        for (let j = 0; j < n; j++) {
                            const k = (i + j) % n;
                            u[k] = (u[k] + currentPublicKey.a[i] * r[j]) % q;
                            v[k] = (v[k] + currentPublicKey.b[i] * r[j]) % q;
                        }
                        u[i] = (u[i] + e1[i]) % q;
                        v[i] = (v[i] + e2[i] + messagePoly[i]) % q;
                    }

                    // Создание шифротекста
                    currentCiphertext = {
                        u: u,
                        v: v,
                        params: currentPublicKey.params,
                        timestamp: new Date().toISOString(),
                        mode: document.getElementById('encryptionMode').value
                    };

                    // Отображение результата
                    displayCiphertext(currentCiphertext);
                    updateStatus('Сообщение успешно зашифровано', 'ready');

                } catch (error) {
                    updateStatus('Ошибка шифрования: ' + error.message, 'error');
                }
            }, 100);
        }

        function decryptMessage() {
            const ciphertextText = document.getElementById('encryptedMessage').value;
            const secretKeyText = document.getElementById('decryptionKey').value;

            if (!ciphertextText || !secretKeyText) {
                updateStatus('Введите шифротекст и секретный ключ', 'error');
                return;
            }

            updateStatus('Дешифрование сообщения...', 'working');
            simulateProgress('decryptProgress', 1500);

            setTimeout(() => {
                try {
                    // Парсинг данных
                    let ciphertext, secretKeyData;
                    
                    try {
                        ciphertext = decodeFromFormat(ciphertextText, detectFormat(ciphertextText));
                        secretKeyData = decodeFromFormat(secretKeyText, detectFormat(secretKeyText));
                    } catch (e) {
                        // Попробуем автоматическое определение
                        ciphertext = autoDetectAndParseFormat(ciphertextText);
                        secretKeyData = autoDetectAndParseFormat(secretKeyText);
                    }

                    const secretKey = secretKeyData.s;
                    const { n, q } = ciphertext.params;

                    // Дешифрование: message = v - u*s
                    const decrypted = new Array(n).fill(0);
                    
                    for (let i = 0; i < n; i++) {
                        for (let j = 0; j < n; j++) {
                            const k = (i + j) % n;
                            decrypted[k] = (decrypted[k] + ciphertext.u[i] * secretKey[j]) % q;
                        }
                    }
                    
                    for (let i = 0; i < n; i++) {
                        decrypted[i] = (ciphertext.v[i] - decrypted[i] + q) % q;
                    }

                    // Декодирование сообщения
                    currentDecryptedMessage = decodeMessage(decrypted, n, q);

                    // Отображение результата
                    document.getElementById('decryptedMessageResult').textContent = currentDecryptedMessage;
                    updateStatus('Сообщение успешно расшифровано', 'ready');

                } catch (error) {
                    updateStatus('Ошибка дешифрования: ' + error.message, 'error');
                }
            }, 100);
        }

        // ============ ВСПОМОГАТЕЛЬНЫЕ ФУНКЦИИ ============

        function encodeMessage(message, n, q) {
            const encoder = new TextEncoder();
            const data = encoder.encode(message);
            const scale = Math.floor(q / 256);
            
            const result = new Array(n).fill(0);
            const maxLength = Math.min(data.length, Math.floor(n / 3)); // Соотношение 3:1
            
            for (let i = 0; i < maxLength; i++) {
                result[i] = (data[i] * scale) % q;
            }
            
            return result;
        }

        function decodeMessage(coefficients, n, q) {
            const scale = Math.floor(q / 256);
            const data = [];
            
            for (let i = 0; i < n; i++) {
                const value = Math.round(coefficients[i] / scale);
                if (value >= 0 && value <= 255) {
                    data.push(value);
                }
                if (value === 0 && i > 0) break;
            }
            
            const decoder = new TextDecoder();
            return decoder.decode(new Uint8Array(data));
        }

        // ============ ФУНКЦИИ РАБОТЫ С ФОРМАТАМИ ============

        function arrayBufferToHex(buffer) {
            return Array.from(new Uint8Array(buffer))
                .map(b => b.toString(16).padStart(2, '0'))
                .join('');
        }

        function hexToArrayBuffer(hex) {
            const bytes = new Uint8Array(hex.length / 2);
            for (let i = 0; i < hex.length; i += 2) {
                bytes[i/2] = parseInt(hex.substr(i, 2), 16);
            }
            return bytes;
        }

        function encodeToFormat(data, format) {
            const jsonData = JSON.stringify(data);
            
            switch (format) {
                case 'json':
                    return JSON.stringify(data, null, 2);
                case 'json-compact':
                    return jsonData;
                case 'base64':
                    return btoa(unescape(encodeURIComponent(jsonData)));
                case 'hex':
                    return arrayBufferToHex(new TextEncoder().encode(jsonData));
                default:
                    return jsonData;
            }
        }

        function decodeFromFormat(data, format) {
            try {
                switch (format) {
                    case 'json':
                    case 'json-compact':
                        return JSON.parse(data);
                    case 'base64':
                        return JSON.parse(decodeURIComponent(escape(atob(data))));
                    case 'hex':
                        const bytes = hexToArrayBuffer(data);
                        return JSON.parse(new TextDecoder().decode(bytes));
                    default:
                        return autoDetectAndParseFormat(data);
                }
            } catch (e) {
                throw new Error(`Ошибка декодирования формата ${format}: ${e.message}`);
            }
        }

        function detectFormat(data) {
            if (!data) return 'json';
            
            // Проверяем на JSON
            try {
                JSON.parse(data);
                return data.includes('\n') ? 'json' : 'json-compact';
            } catch (e) {}
            
            // Проверяем на base64
            if (/^[A-Za-z0-9+/=]+$/.test(data) && data.length % 4 === 0) {
                try {
                    atob(data);
                    return 'base64';
                } catch (e) {}
            }
            
            // Проверяем на hex
            if (/^[0-9A-Fa-f]+$/.test(data)) {
                return 'hex';
            }
            
            return 'json'; // По умолчанию
        }

        function autoDetectAndParseFormat(data) {
            try {
                return JSON.parse(data);
            } catch (e) {
                try {
                    return decodeFromFormat(data, 'base64');
                } catch (e2) {
                    try {
                        return decodeFromFormat(data, 'hex');
                    } catch (e3) {
                        throw new Error('Не удалось определить формат данных');
                    }
                }
            }
        }

        function insertLineBreaks(text, chunkSize) {
            if (chunkSize === 'none') return text;
            const size = parseInt(chunkSize);
            const regex = new RegExp(`.{1,${size}}`, 'g');
            const matches = text.match(regex);
            return matches ? matches.join('\n') : text;
        }

        // ============ ФУНКЦИИ ИНТЕРФЕЙСА ============

        function displayKeys() {
            const keyFormat = RLWE_CONFIG.formats.key;
            const includeMetadata = RLWE_CONFIG.formats.includeMetadata;
            const lineBreaks = RLWE_CONFIG.formats.lineBreaks;
            
            const publicKeyData = {
                a: currentPublicKey.a,
                b: currentPublicKey.b,
                params: currentPublicKey.params
            };
            
            const secretKeyData = {
                s: currentSecretKey,
                params: currentParams
            };
            
            if (includeMetadata) {
                publicKeyData.metadata = {
                    timestamp: currentPublicKey.timestamp,
                    comment: currentPublicKey.comment,
                    algorithm: 'RLWE',
                    securityLevel: RLWE_CONFIG.security.level
                };
            }
            
            let publicKeyText = encodeToFormat(publicKeyData, keyFormat);
            let secretKeyText = encodeToFormat(secretKeyData, keyFormat);
            
            if (lineBreaks !== 'none') {
                publicKeyText = insertLineBreaks(publicKeyText, lineBreaks);
                secretKeyText = insertLineBreaks(secretKeyText, lineBreaks);
            }
            
            document.getElementById('publicKeyDisplay').textContent = publicKeyText;
            document.getElementById('secretKeyDisplay').textContent = secretKeyText;
        }

        function displayCiphertext(ciphertext) {
            const messageFormat = RLWE_CONFIG.formats.message;
            const lineBreaks = RLWE_CONFIG.formats.lineBreaks;
            
            let ciphertextText = encodeToFormat(ciphertext, messageFormat);
            
            if (lineBreaks !== 'none') {
                ciphertextText = insertLineBreaks(ciphertextText, lineBreaks);
            }
            
            document.getElementById('encryptedMessageResult').textContent = ciphertextText;
        }

        function simulateProgress(progressId, duration) {
            let width = 0;
            const interval = 30;
            const steps = duration / interval;
            const increment = 100 / steps;
            
            const progressInterval = setInterval(() => {
                if (width >= 100) {
                    clearInterval(progressInterval);
                } else {
                    width += increment;
                    document.getElementById(progressId).style.width = Math.min(width, 100) + '%';
                }
            }, interval);
        }

        function updateStatus(message, type = 'ready') {
            const indicator = document.getElementById('statusIndicator');
            const statusText = document.getElementById('statusText');
            
            indicator.className = 'status-indicator';
            if (type === 'working') indicator.classList.add('status-working');
            if (type === 'error') indicator.classList.add('status-error');
            
            statusText.textContent = message;
        }

        function switchTab(tabName) {
            document.querySelectorAll('.tab').forEach(tab => tab.classList.remove('active'));
            document.querySelectorAll('.tab-content').forEach(content => content.classList.remove('active'));
            
            const tabs = ['params', 'keys', 'encrypt', 'decrypt', 'formats'];
            const tabIndex = tabs.indexOf(tabName);
            
            if (tabIndex >= 0) {
                document.querySelector(`.tab:nth-child(${tabIndex + 1})`).classList.add('active');
                document.getElementById(`${tabName}-tab`).classList.add('active');
            }
        }

        function saveParameters() {
            RLWE_CONFIG.security.level = document.getElementById('securityLevel').value;
            RLWE_CONFIG.security.modulusType = document.getElementById('modulusType').value;
            RLWE_CONFIG.security.errorDistribution = document.getElementById('errorDistribution').value;
            RLWE_CONFIG.security.encodingScheme = document.getElementById('encodingScheme').value;
            
            initializeRLWE();
            updateStatus('Параметры безопасности применены', 'ready');
        }

        function applyFormatSettings() {
            RLWE_CONFIG.formats.key = document.getElementById('keyFormat').value;
            RLWE_CONFIG.formats.message = document.getElementById('messageFormat').value;
            RLWE_CONFIG.formats.lineBreaks = document.getElementById('lineBreaks').value;
            RLWE_CONFIG.formats.includeMetadata = document.getElementById('includeMetadata').checked;
            
            if (currentPublicKey) {
                displayKeys();
            }
            
            updateStatus('Настройки форматов применены', 'ready');
        }

        function copyPublicKey() {
            copyToClipboard('publicKeyDisplay', 'Публичный ключ скопирован');
        }

        function copySecretKey() {
            copyToClipboard('secretKeyDisplay', 'Секретный ключ скопирован');
        }

        function copyEncryptedMessage() {
            copyToClipboard('encryptedMessageResult', 'Зашифрованное сообщение скопировано');
        }

        function copyDecryptedMessage() {
            copyToClipboard('decryptedMessageResult', 'Расшифрованное сообщение скопировано');
        }

        function copyToClipboard(elementId, successMessage) {
            const text = document.getElementById(elementId).textContent;
            if (text && !text.includes('не сгенерирован')) {
                navigator.clipboard.writeText(text).then(() => {
                    updateStatus(successMessage, 'ready');
                }).catch(err => {
                    updateStatus('Ошибка копирования: ' + err, 'error');
                });
            }
        }

        function downloadPublicKey() {
            downloadContent('publicKeyDisplay', 'rlwe_public_key.json');
        }

        function downloadSecretKey() {
            downloadContent('secretKeyDisplay', 'rlwe_secret_key.json');
        }

        function downloadEncryptedMessage() {
            downloadContent('encryptedMessageResult', 'encrypted_message.txt');
        }

        function downloadDecryptedMessage() {
            downloadContent('decryptedMessageResult', 'decrypted_message.txt');
        }

        function downloadContent(elementId, filename) {
            const text = document.getElementById(elementId).textContent;
            if (text && !text.includes('не сгенерирован')) {
                const blob = new Blob([text], { type: 'text/plain' });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = filename;
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
                URL.revokeObjectURL(url);
                updateStatus('Файл сохранен', 'ready');
            }
        }

        function showPublicKeyInfo() {
            if (!currentPublicKey) return;
            showModal('Информация о публичном ключе', `
Размер: ${JSON.stringify(currentPublicKey).length} байт
Параметры: n=${currentParams.n}, q=${currentParams.q}
Безопасность: ${RLWE_CONFIG.security.level} бит
Время генерации: ${currentPublicKey.timestamp}
Комментарий: ${currentPublicKey.comment || 'Отсутствует'}
            `);
        }

        function showSecretKeyInfo() {
            if (!currentSecretKey) return;
            showModal('Информация о секретном ключе', `
Размер: ${JSON.stringify({s: currentSecretKey}).length} байт
Параметры: n=${currentParams.n}, q=${currentParams.q}
Безопасность: ${RLWE_CONFIG.security.level} бит
Тип: Секретный ключ
            `);
        }

        function analyzeCiphertext() {
            if (!currentCiphertext) {
                const ciphertextText = document.getElementById('encryptedMessageResult').textContent;
                if (!ciphertextText) return;
                
                try {
                    currentCiphertext = autoDetectAndParseFormat(ciphertextText);
                } catch (e) {
                    updateStatus('Неверный формат шифротекста', 'error');
                    return;
                }
            }
            
            const size = JSON.stringify(currentCiphertext).length;
            const textSize = document.getElementById('messageToEncrypt').value.length;
            const ratio = (size / textSize).toFixed(1);
            
            showModal('Анализ шифротекста', `
Размер шифротекста: ${size} байт
Размер исходного текста: ${textSize} байт
Соотношение: ${ratio}:1
Параметры: n=${currentCiphertext.params.n}, q=${currentCiphertext.params.q}
Режим шифрования: ${currentCiphertext.mode || 'standard'}
Время создания: ${currentCiphertext.timestamp}
            `);
        }

        function verifyDecryption() {
            const decrypted = document.getElementById('decryptedMessageResult').textContent;
            const original = document.getElementById('messageToEncrypt').value;
            
            if (decrypted && original && decrypted === original) {
                showModal('Проверка дешифрования', '✅ Дешифрование выполнено успешно!\nСообщение соответствует оригиналу.');
            } else if (decrypted) {
                showModal('Проверка дешифрования', '⚠️ Дешифрование завершено.\nНевозможно проверить соответствие оригиналу.');
            }
        }

        function showModal(title, content) {
            document.getElementById('modalContent').innerHTML = `
                <h3>${title}</h3>
                <pre style="background: rgba(13,27,42,0.8); padding: 15px; border-radius: 5px; overflow: auto;">${content}</pre>
            `;
            document.getElementById('infoModal').style.display = 'block';
        }

        function closeModal() {
            document.getElementById('infoModal').style.display = 'none';
        }

        // Закрытие модального окна по клику вне его
        window.onclick = function(event) {
            const modal = document.getElementById('infoModal');
            if (event.target == modal) {
                closeModal();
            }
        }

        // Инициализация системы
        document.addEventListener('DOMContentLoaded', function() {
            initializeRLWE();
            
            // Устанавливаем значения по умолчанию
            document.getElementById('securityLevel').value = RLWE_CONFIG.security.level;
            document.getElementById('modulusType').value = RLWE_CONFIG.security.modulusType;
            document.getElementById('errorDistribution').value = RLWE_CONFIG.security.errorDistribution;
            document.getElementById('encodingScheme').value = RLWE_CONFIG.security.encodingScheme;
            document.getElementById('keyFormat').value = RLWE_CONFIG.formats.key;
            document.getElementById('messageFormat').value = RLWE_CONFIG.formats.message;
            document.getElementById('lineBreaks').value = RLWE_CONFIG.formats.lineBreaks;
            document.getElementById('includeMetadata').checked = RLWE_CONFIG.formats.includeMetadata;
        });
    </script>
</body>
    </html>
